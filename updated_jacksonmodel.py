# -*- coding: utf-8 -*-
"""Updated_JacksonModel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WMID8lizgg0qTt6nS-CCJV88nMyI7YjX
"""

#!pip install simpy



import simpy
import numpy as np
import random

selection=2
TWTQ2=0.0
TWTQ3=0.0
TWTQ2count=0
TWTQ3count=0

ArrivalTimeDeviceId={}
ArrivalTimeAtQ1={}
ReleaseTimeAtQ1={}
ServiceTimeAtQ1={}
ArrivalTimeAtQ2={}
ArrivalTimeAtQ3={}
ArrivalTimeAtS1={}
ReleaseTimeAtS1={}
ServiceTimeAtQ2={}
ServiceTimeAtQ3={}

#arrival function
def arrival_time(prio):
    
    if prio ==1:
      return np.random.uniform(1.0)
    if prio ==2:
      return np.random.poisson(1.0028)
    if prio == 3:
      return np.random.poisson(2.0)
    if prio == 4:
      return np.random.uniform(10.0)

def servicetime(tname):
    m,n,o,p = tname.split("_")
    o=int(o)
    #print("type of Task:",type(o))
    #print("priority value",o)
    if o ==1:
      return np.random.uniform(4.5262)
    if o == 2:
      return np.random.uniform(4.5262)
    if o ==3:
      return np.random.uniform(4.5262)
    if o == 4:
      return np.random.uniform(4.5262)

class Store1():
  def __init__(self,env,initialitem):
        self.env=env
        self.initialitem=initialitem
  def loadData(self,env,int1):
        yield self.env.timeout(0.01)
        yield store.put(int1)
  def putItem(x):
        yield self.env.timeout(0.05)
        yield store.put(x)

def Q1Queue(env1,taskname1):
  env=env1
  taskname=taskname1
  #step5
  ArrivalTimeAtQ1[taskname]=env.now
  with Q1.request() as req:
    #step6
    
    yield req
    yield env.timeout(.011) #time is constant here, you can create custom method to assign custom value here.
    #step7
    ReleaseTimeAtQ1[taskname]=env.now
    #step8
    ServiceTimeAtQ1[taskname]=.011 #it is constant, if it custom valueupdate in dictionary accordingly.

def FCFSModel(env1,taskname1):
  env=env1
  taskname=taskname1
  #step10
  #call load distributor
  ''' The load distributor model works on a concept of load balancing. If the load of low priority queue is below the 
  point, a load shifting model immediately activated and load the high priority tasks into low priority queue.
  for this point we are implmentating only , task type segregation. in future we will include the load balancing and shifting
  model. We need task picking factor to adjust the load of the queues. This feature can only be available on 
  weighted queue model.
  '''
  #step11
  #find the task priority value
  a,b,c,d = taskname.split("_")
  Z=int(c)
  #print(len(store.items))
  srvctime=servicetime(taskname)
  if Z in [1,2,3,4]:
    ArrivalTimeAtQ2[taskname]=env.now
    #call Q2Queue
    #yield env.timeout(1) only appended to remove the None Type error value error
    with Q2.request() as reqQ2:
      yield reqQ2
      #check the resource container shared by all the types of task.
      item = yield store.get()
      ArrivalTimeAtS1[taskname]=env.now
      #print("Task {} requesting item {}".format(taskname,item))
      yield env.timeout(srvctime)
      ServiceTimeAtQ2[taskname]=srvctime
      
  else:
    #use for dummy data #otherwise you will get error in Q3 performance
    ArrivalTimeAtQ3[taskname]=env.now
    #call Q3Queue
    ArrivalTimeAtS1[taskname]=env.now
    ServiceTimeAtQ3[taskname]=srvctime
      
  yield store.put('VM')
  #print("Task {} release VM at {}".format(taskname,env.now))
  ReleaseTimeAtS1[taskname]=env.now

def LoadModel(env1,taskname1):
  env=env1
  taskname=taskname1
  global TWTQ2
  global TWTQ3
  global TWTQ2count
  global TWTQ3count

  #calculate avg waiting time at Q2
  '''
  countD1=0
  WTQ2=0.0
  if len(ArrivalTimeAtQ2.keys())==0:
    WTQ2=0.0
  else:
    for y in ArrivalTimeAtQ2.keys():
      for c in ReleaseTimeAtS1.keys():
        for d in ServiceTimeAtQ2.keys():
          if y==c==d :
            countD1=countD1+1
            
            WTQ2=WTQ2+(ReleaseTimeAtS1[y]-ArrivalTimeAtQ2[y])-ServiceTimeAtQ1[y]
    if countD1!=0:
      WTQ2=WTQ2/countD1
    else:
      WTQ2=0.0
  #calculate avg waiting time at Q3
  countD3=0
  WTQ3=0.0
  if len(ArrivalTimeAtQ3.keys())==0:
    WTQ3=0.0
  else:
    for z in ArrivalTimeAtQ3.keys():
      for e in ReleaseTimeAtS1.keys():
        for f in ServiceTimeAtQ3.keys():
          if z==e==f :
            countD3=countD3+1
            WTQ3=WTQ3+(ReleaseTimeAtS1[z]-ArrivalTimeAtQ3[z])
    if countD3!=0:
      WTQ3=WTQ3/countD3
    else:
      WTQ3=0.0'''
  CL2=len(Q2.queue)
  CL3=len(Q3.queue)
  #print("WTQ2 {} and WTQ3 {}".format(TWTQ2,TWTQ3))
  #print("CL2 {} and CL3 {}".format(CL2,CL3))
  #step10
  #call load distributor
  ''' The load distributor model works on a concept of load balancing. If the load of low priority queue is below the 
  point, a load shifting model immediately activated and load the high priority tasks into low priority queue.
  for this point we are implmentating only , task type segregation. in future we will include the load balancing and shifting
  model. We need task picking factor to adjust the load of the queues. This feature can only be available on 
  weighted queue model.
  '''
  #step11
  #find the load factor value related to both queues
  srvctime=servicetime(taskname)
  #LFQ2= WTQ2*(CL2/4)/srvctime
  LFQ2= TWTQ2*(CL2/4)
  #LFQ3=WTQ3*(CL3/4)/srvctime
  LFQ3=TWTQ3*(CL3/4)
  #print("LFQ2 {} and LFQ3 {}".format(LFQ2,LFQ3))
  if LFQ2<LFQ3:
    #print("Called load model with prio")
    ArrivalTimeAtQ2[taskname]=env.now
    #call Q2Queue
    #yield env.timeout(1) only appended to remove the None Type error value error
    with Q2.request() as reqQ2:
      yield reqQ2
      #check the resource container shared by all the types of task.
      item = yield store.get()
      ArrivalTimeAtS1[taskname]=env.now
      #print("Task {} requesting item {}".format(taskname,item))
      yield env.timeout(srvctime)
      ServiceTimeAtQ2[taskname]=srvctime
      TWTQ2count=TWTQ2count+1
      TWTQ2=TWTQ2+(((ArrivalTimeAtS1[taskname]-ArrivalTimeAtQ2[taskname])-TWTQ2)/TWTQ2count)

      
  else:
    #print("Called load model with non prio")
    ArrivalTimeAtQ3[taskname]=env.now
    #call Q3Queue
    with Q3.request() as reqQ3:
      yield reqQ3
      item = yield store.get()
      ArrivalTimeAtS1[taskname]=env.now
      #print("Task {} requesting item {}".format(taskname,item))
      yield env.timeout(srvctime)
      ServiceTimeAtQ3[taskname]=srvctime
      TWTQ3count=TWTQ3count+1
      TWTQ3=TWTQ3+(((ArrivalTimeAtS1[taskname]-ArrivalTimeAtQ3[taskname])-TWTQ3)/TWTQ3count)
  yield store.put('VM')
  #print("Task {} release VM at {}".format(taskname,env.now))
  ReleaseTimeAtS1[taskname]=env.now

def RandomModel(env1,taskname1):
  env=env1
  taskname=taskname1
  #step10
  #call load distributor
  ''' The load distributor model works on a concept of load balancing. If the load of low priority queue is below the 
  point, a load shifting model immediately activated and load the high priority tasks into low priority queue.
  for this point we are implmentating only , task type segregation. in future we will include the load balancing and shifting
  model. We need task picking factor to adjust the load of the queues. This feature can only be available on 
  weighted queue model.
  '''
  #step11
  list1=[0,1]
  x=random.choice(list1)
  srvctime=servicetime(taskname)
  if x==0:
    ArrivalTimeAtQ2[taskname]=env.now
    #call Q2Queue
    #yield env.timeout(1) only appended to remove the None Type error value error
    with Q2.request() as reqQ2:
      yield reqQ2
      #check the resource container shared by all the types of task.
      item = yield store.get()
      ArrivalTimeAtS1[taskname]=env.now
      #print("Task {} requesting item {}".format(taskname,item))
      yield env.timeout(srvctime)
      ServiceTimeAtQ2[taskname]=srvctime
  else:
    ArrivalTimeAtQ3[taskname]=env.now
    #call Q3Queue
    with Q3.request() as reqQ3:
      yield reqQ3
      item = yield store.get()
      ArrivalTimeAtS1[taskname]=env.now
      #print("Task {} requesting item {}".format(taskname,item))
      yield env.timeout(srvctime)
      ServiceTimeAtQ3[taskname]=srvctime
  yield store.put('VM')
  #print("Task {} release VM at {}".format(taskname,env.now))
  ReleaseTimeAtS1[taskname]=env.now

def JacksonWeighted(env1,taskname1):
  env=env1
  taskname=taskname1
  #step10
  #call load distributor
  ''' The load distributor model works on a concept of load balancing. If the load of low priority queue is below the 
  point, a load shifting model immediately activated and load the high priority tasks into low priority queue.
  for this point we are implmentating only , task type segregation. in future we will include the load balancing and shifting
  model. We need task picking factor to adjust the load of the queues. This feature can only be available on 
  weighted queue model.
  '''
  #step11
  #find the task priority value
  a,b,c,d = taskname.split("_")
  Z=int(c)
  #print(len(store.items))
  srvctime=servicetime(taskname)
  if Z in [1,2]:
    ArrivalTimeAtQ2[taskname]=env.now
    #call Q2Queue
    #yield env.timeout(1) only appended to remove the None Type error value error
    with Q2.request() as reqQ2:
      yield reqQ2
      #check the resource container shared by all the types of task.
      item = yield store.get()
      ArrivalTimeAtS1[taskname]=env.now
      #print("Task {} requesting item {}".format(taskname,item))
      yield env.timeout(srvctime)
      ServiceTimeAtQ2[taskname]=srvctime
      
  else:
    ArrivalTimeAtQ3[taskname]=env.now
    #call Q3Queue
    with Q3.request() as reqQ3:
      yield reqQ3
      item = yield store.get()
      ArrivalTimeAtS1[taskname]=env.now
      #print("Task {} requesting item {}".format(taskname,item))
      yield env.timeout(srvctime)
      ServiceTimeAtQ3[taskname]=srvctime
      
  yield store.put('VM')
  #print("Task {} release VM at {}".format(taskname,env.now))
  ReleaseTimeAtS1[taskname]=env.now

class GenTask(object):
    def __init__(self, env,name,prio):
      self.env = env
      self.name=name
      self.prio=prio
      #call the modules according to ypur proposed model
      self.action = env.process(self.generator_task())
    def generator_task(self):
      #generate task with arrival time, implement a arrival function to reterive the arrival pattern
        i=0
        while True:
          #step2
          arr=arrival_time(self.prio)
          yield self.env.timeout(arr)
          #additional *step
          taskname=self.name+str(i) 
          #step3
          ArrivalTimeDeviceId[taskname]=arr
          #step4 from 4 to 8 steps are executed under Q1Queue method
          #call Q1Queue()
          yield env.process(Q1Queue(env,taskname))
          #step9
          #call comparison model
          if selection ==1:
            #call jackson weighted model
            yield env.process(JacksonWeighted(env,taskname))
            pass
          elif selection ==2:
            #load balancing model
            yield env.process(LoadModel(env,taskname))
          elif selection==3:
            #call FCFS model
            yield env.process(FCFSModel(env,taskname))
          elif selection ==4:
            #call random model
            yield env.process(RandomModel(env,taskname))
          else:
            print("Unknown model")
            exit(0)
          i=i+1

env = simpy.Environment() #creating simpy environment object
#if required create resources such as queue and resource bundle

Q1 = simpy.Resource(env,capacity=1) #max. capacity 1 server at a time

Q2=simpy.Resource(env,capacity=75) # you can set capacity according to your model

Q3=simpy.Resource(env,capacity=25) # you can set capacity according to your model

S1=simpy.Store(env,capacity=100) #maximum VMs available

store = simpy.Store(env, capacity=100)

st1=Store1(env,10)
for i in range(10):
    env.process(st1.loadData(env,'VM'))

from numpy.random import choice
tasktype=[1,2,3,4]
pvalues=[0.10,0.15,0.25,.50]
for x in range(200):
  #pr=random.choice(tasktype,pvalues)
  pr=choice(tasktype,p=pvalues)
  GenT = GenTask(env,name="healthmonitor_"+str(x)+"_"+str(pr)+"_",prio=pr) # there should be corresponding GenT class

env.run(until=1800) #environment running for t time

print("total task generated:",end="; ")
print(len(ArrivalTimeDeviceId.keys()))

#Avg. waiting @ Q1
countD=0
WTQ1=0.0
for x in ArrivalTimeAtQ1.keys():
  for a in ReleaseTimeAtQ1.keys():
    for b in ServiceTimeAtQ1.keys():
      if x==a==b :
        countD=countD+1
        WTQ1=WTQ1+(ReleaseTimeAtQ1[x]-ArrivalTimeAtQ1[x])-ServiceTimeAtQ1[x]
print("Avg WT at Q1: ;",WTQ1/countD)

#Avg Wating Time @Q2
countD1=0
WTQ2=0.0
for y in ArrivalTimeAtQ2.keys():
  for c in ReleaseTimeAtS1.keys():
    for d in ServiceTimeAtQ2.keys():
      if y==c==d :
        countD1=countD1+1
        #print("A {}, R {}, S{}".format(ArrivalTimeAtQ2[y],ReleaseTimeAtS1[y],ServiceTimeAtQ2[y]))
        WTQ2=WTQ2+(ReleaseTimeAtS1[y]-ArrivalTimeAtQ2[y])-ServiceTimeAtQ1[y]
print("Avg WT at Q2: ;",WTQ2/countD1)

if (selection !=3):
  #Avg Wating Time @Q3
  countD3=0
  WTQ3=0.0
  for z in ArrivalTimeAtQ3.keys():
    for e in ReleaseTimeAtS1.keys():
      for f in ServiceTimeAtQ3.keys():
        if z==e==f :
          countD3=countD3+1
          WTQ3=WTQ3+(ReleaseTimeAtS1[z]-ArrivalTimeAtQ3[z])
  print("Avg WT at Q3: ;",WTQ3/countD3)
  print("Average Response time ;{}".format(     (((WTQ1/countD + WTQ2/countD1)/2) + ((WTQ1/countD + WTQ3/countD3)/2))))
else:
  print("Avg WT at Q3: ;",0.0)
  print("Average Response time ;{}".format(     (WTQ1/countD + WTQ2/countD1)))

